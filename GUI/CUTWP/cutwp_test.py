# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'C:\Users\joelb\pyCUFSM\GUI\CUTWP\cutwp_test.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import numpy as np
import re

import sys
sys.setrecursionlimit(1000000000)

def Pe_out(Pe):
    Pe1 = []
    Pe2 = []
    Pe = np.array(Pe)
    for i in range(len(Pe)):
        if(Pe[i]>=0):
            Pe1.append(Pe[i])
        if(Pe[i]<0):
            Pe2.append(Pe[i])
    Pe1.sort()
    Pe2.sort(reverse=True)
    for i in range(len(Pe)):
        if(i<len(Pe1)):
            Pe[i] = Pe1[i]
        elif(i>=len(Pe1)):
            Pe[i] = Pe2[i-len(Pe1)]
    return Pe
def cutwp_prop(coord,ends,KL1,KL2,KL3,force,exy,E,v,dist):
    import numpy as np
    import copy
    #   Adopted as cutwp_prop for use in CUFSM by Adany and Schafer in 2004
    #   with permission of Sarawit.
    # 
    #   December 2006 fixed bugs with beta calculations. (Schafer)
    # 
    #   Compute cross section properties 
    # ----------------------------------------------------------------------------
    #   Written by:
    #        Andrew T. Sarawit
    #        last revised:   Wed 10/25/01
    #        
    #   Function purpose:
    #        This function computes the cross section properties: area, centroid, 
    #        moment of inertia, torsional constant, shear center, warping constant, 
    #        B1, B2, elastic critical buckling load and the deformed buckling shape   
    # 
    #   Dictionary of Variables
    #      Input Information:
    #        coord(i,1:2)   ==  node i's coordinates
    #                             coord(i,1) = X coordinate
    #                             coord(i,2) = Y coordinate
    #        ends(i,1:2)    ==  subelement i's nodal information
    #                             ends(i,1) = start node #
    #                             ends(i,2) = finish node #
    #                             ends(i,3) = element's thickness 
    #        KL1            ==  effective unbraced length for bending about the 1-axis
    #        KL2            ==  effective unbraced length for bending about the 2-axis
    #        KL3            ==  effective unbraced length for twisting about the 3-axis
    #        force          ==  type of force applied
    #                       == 'Pe'  : elastic critical axial force 
    #                       == 'Me1' : elastic critical moment about the 1-axis 
    #                       == 'Me2' : elastic critical moment about the 2-axis
    #        exy(1:2)     ==  Pe eccentricities coordinates
    #                             exy(1) = ex
    #                             exy(2) = ey
    #   Output Information:
    #        A              ==  cross section area
    #        xc             ==  X coordinate of the centroid from orgin
    #        yc             ==  Y coordinate of the centroid from origin
    #        Ix             ==  moment of inertia about centroid X axes
    #        Iy             ==  moment of inertia about centroid Y axes
    #        Ixy            ==  product of inertia about centroid
    #        Iz             ==  polar moment of inertia about centroid
    #        theta          ==  rotation angle for the principal axes
    #        I1             ==  principal moment of inertia about centroid 1 axes 
    #        I2             ==  principal moment of inertia about centroid 2 axes
    #        J              ==  torsional constant
    #        xs             ==  X coordinate of the shear center from origin
    #        ys             ==  Y coordinate of the shear center from origin
    #        Cw             ==  warping constant
    #        B1             ==  int(y*(x**2+y^2),s,0,L)  
    #        B2             ==  int(x*(x^2+y^2),s,0,L)
    #                           where: x = x1+s/L*(x2-x1)
    #                                  y = y1+s/L*(y2-y1)
    #                                  L = lenght of the element
    #        Pe(i)          ==  buckling mode i's elastic critical buckling load
    #        dcoord         ==  node i's coordinates of the deformed buckling shape 
    #                             coord(i,1,mode) = X coordinate 
    #                             coord(i,2,mode) = Y coordinate
    #                           where: mode = buckling mode number  
    # 
    #   Note: 
    #      J,xs,ys,Cw,B1,B2,Pe,dcoord is not computed for close-section      
    #        
    # ----------------------------------------------------------------------------
    # 
    #  find nele  == total number of elements 
    #       nnode == total number of nodes 
    #       j     == total number of 2 element joints 
    coord = np.array(coord)
    ends = np.array(ends)
    nele = len(ends)
    nodes = copy.deepcopy(ends[:, 0:2])
    nodes = nodes.T.flatten()
    nodes = np.array(nodes)
    nnodes = 0
    j =0 
    while len(nodes)>0:
        nodes_1 = copy.deepcopy(nodes)
        i = []
        z = 0
        for x in range(len(nodes)):
            if(nodes[x]==nodes[0]):
                nodes_1 = np.delete(nodes_1, x-z)
                z +=1
                i.append(x)
        nodes = copy.deepcopy(nodes_1)
        if len(i) ==2:
            j = j + 1
        nnodes = nnodes + 1
    # Classify the section type
    if j == nele:
        section = 'close'
    else:
        section = 'open'
    
    # if the section is close reorder the element
    if section == 'close' : 
        xnele = nele - 1
        for i in range(xnele):
            en = cpoy.deepcopy(ends)
            en[i, 1] = 0
            m, n = np.argwhere(ends[i, 1]==en[:, 0:2])
            if n == 1:
                ends[i+1, :] = en[m, :]
                ends[m, :] = en[i+1, :]
            if  n ==2:
                ends[i+1, :] = en[m, [1, 0, 2]]
                ends[m, :] = en[i+1, [1, 0, 2]]
    ###Find the element properties
    t = np.zeros(len(ends))
    xm = np.zeros(len(ends))
    ym = np.zeros(len(ends))
    xd = np.zeros(len(ends))
    yd = np.zeros(len(ends))
    L = np.zeros(len(ends))
    for i in range(nele):
        sn = int(ends[i, 0])-1
        fn = int(ends[i, 1])-1
        t[i] = ends[i, 2]
        #Compute coordinate of midpoint of the element
        xm[i] = np.mean([coord[sn, 0], coord[fn, 0]])
        ym[i] = np.mean([coord[sn, 1], coord[fn, 1]])
        #Compute the dimension of the element
        xd[i] = np.diff([coord[sn, 0], coord[fn, 0]])
        yd[i] = np.diff([coord[sn, 1], coord[fn, 1]])
        #Compute length
        L[i] = np.sqrt(xd[i]**2 + yd[i]**2)
    #Compute Area
    A = np.sum(L*t)
    #Compute centroid
    xc = np.sum(L*t*xm)/A
    yc = np.sum(L*t*ym)/A

    if np.abs(xc/np.sqrt(A))<1e-12:
        xc = 0
    if np.abs(yc/np.sqrt(A))<1e-12:
        yc = 0

    #Compute moment of inertia
    Ix = np.sum((yd**2/12 + (ym-yc)**2)*L*t)
    Iy = np.sum((xd**2/12 + (xm-xc)**2)*L*t)
    Ixy = np.sum((xd*yd/12 + (xm-xc)*(ym-yc)*L*t))

    if np.abs(Ixy/A**2)<1e-12:
        Ixy = 0
    #Compute rotation angle for the principal axes
    theta = (np.angle([(Ix-Iy)-2*Ixy*1j])/2)[0]

    #Transfer section coordinates to the centroid principal coordinates
    coord12 = np.zeros((len(coord), 2))
    coord12[:, 0] = coord[:, 0] - xc
    coord12[:, 1] = coord[:, 1] - yc
    coord12 = [[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]]@(np.array(coord12).T)
    coord12 = np.array(coord12).T

    #Find the element properties
    for i in range(nele):
        sn = int(ends[i, 0])-1
        fn = int(ends[i, 1])-1
        #Compute coordinate of midpoint of the element
        xm[i] = np.mean([coord12[sn, 0], coord12[fn, 0]])
        ym[i] = np.mean([coord12[sn, 1], coord12[fn, 1]])
        #Compute the dimension of the element
        xd[i] = np.diff([coord12[sn, 0], coord12[fn, 0]])
        yd[i] = np.diff([coord12[sn, 1], coord12[fn, 1]])
    #Compute the principal moment of inertia
    I1 = np.sum((yd**2/12 + (ym)**2)*L*t)
    I2 = np.sum((xd**2/12 + (xm)**2)*L*t)
    
    if section == 'close':
        # Compute torsional constant
        for i in range(nele):
            sn = ends[i, 0]
            fn = ends[i, 1]
            p[i] = ((coord[sn,0]-xc)*(coord[fn,1]-yc)-(coord[fn,0]-xc)*(coord[sn,1]-yc))/L[i]
        J = 4*np.sum(p*L/2)**2/np.sum(L/t)
        xs = np.NaN
        ys = np.NaN
        Cw = np.NaN
        B1 = np.NaN
        B2 = np.NaN
        Pe = np.NaN
        dcoord = np.NaN

    if section == 'open':
        #Compute torsional constant
        J = np.sum(L*t**3)/3
        #Compute shear center and initialize variables
        nnodes = len(coord)
        w = np.zeros((nnodes, 2))
        w[int(ends[0, 0]), 0] = int(ends[0, 0])
        wo = np.zeros((nnodes, 2))
        wo[int(ends[0, 0]), 0] = int(ends[0, 0])
        Iwx = 0
        Iwy = 0
        wno = 0
        Cw = 0
        # ends[:,0:2] = (ends[:, 0:2]) + 1
        for m in range(nele):
            i = 0
            while(i < len(ends) - 1 and ((np.any(w[:, 0]==ends[i, 0]) and np.any(w[:, 0]==ends[i, 1])) or (not (np.any(w[:, 0]==ends[i, 0])) and (not np.any(w[:, 0]==ends[i, 1]))))):
                i = i+1
                print('in')
            sn = int(ends[i, 0]) - 1
            fn = int(ends[i, 1]) - 1
            p = ((coord[sn, 0]-xc)*(coord[fn, 1]-yc)-(coord[fn, 0]-xc)*(coord[sn, 1]-yc))/L[i]  
            if w[sn, 0] == 0:
                w[sn, 0] = sn+1
                w[sn, 1] = w[fn, 1]-p*L[i]
            elif w[fn, 0] == 0:
                w[fn, 0] = fn+1
                w[fn, 1] = w[sn, 1]+p*L[i]
            Iwx = Iwx+(1/3*(w[sn,1]*(coord[sn, 0]-xc)+w[fn, 1]*(coord[fn, 0]-xc))+1/6*(w[sn,1]*(coord[fn, 0]-xc)+w[fn, 1]*(coord[sn, 0]-xc)))*t[i]* L[i]
            Iwy = Iwy+(1/3*(w[sn,1]*(coord[sn, 1]-yc)+w[fn, 1]*(coord[fn, 1]-yc))+1/6*(w[sn,1]*(coord[fn, 1]-yc)+w[fn, 1]*(coord[sn, 1]-yc)))*t[i]* L[i]
        if (Ix*Iy-Ixy**2)!=0:
            xs = (Iy*Iwy-Ixy*Iwx)/(Ix*Iy-Ixy**2)+xc
            ys = -(Ix*Iwx-Ixy*Iwy)/(Ix*Iy-Ixy**2)+yc
        else:
            xs = xc
            ys = yc
        if np.abs(xs/np.sqrt(A))<1e-12:
            xs = 0
        if np.abs(ys/np.sqrt(A))<1e-12:
            ys = 0
        #Compute unit warping
        for m in range(nele):
            i = 0
            while(i < len(ends) - 1 and ((np.any(w[:, 0]==ends[i, 0]) and np.any(w[:, 0]==ends[i, 1])) or (not (np.any(w[:, 0]==ends[i, 0])) and (not np.any(w[:, 0]==ends[i, 1]))))):
                i = i+1
            sn = int(ends[i, 0]) - 1
            fn = int(ends[i, 0]) - 1
            po = ((coord[sn, 0]-xs)*(coord[fn, 1]-ys)-(coord[fn, 0]-xs)*(coord[sn, 1]-ys))/L[i]  
            if w[sn, 0] == 0:
                w[sn, 0] = sn+1
                w[sn, 1] = w[fn, 1]-po*L[i]
            elif w[fn, 0] == 0:
                w[fn, 0] = fn+1
                w[fn, 1] = w[sn, 1]+po*L[i]
            wno = wno + 1/(2*A)*(wo[sn, 1]+wo[fn, 1])*t[i]*L[i]
        wn = np.zeros((len(wo), 2))
        wn = wno - wo[:, 1]
        #Compute the warping constant
        for i in range(nele):
            sn = int(ends[i, 0]) - 1
            fn = int(ends[i, 1]) - 1
            Cw = Cw + 1/3*(wn[sn]**2+wn[sn]*wn[fn]+wn[fn]**2)*t[i]*L[i]
        #transfer the shear center coordinates to the centroid principal coordinates
        s12 = [[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]]@(np.array([xs-xc, ys-yc]).T)
        #compute the polar radius of gyration of cross section about shear center
        ro = np.sqrt((I1+I2)/A+s12[0]**2+s12[1]**2)

        # Compute the shear modulus
        G = E/(2*(1+v))

        #Compute B1 and B2
        B1 = 0
        B2 = 0
        for i in range(nele):
            sn = int(ends[i, 0])-1
            fn = int(ends[i, 1])-1
            x1 = coord12[sn, 0]
            y1 = coord12[sn, 1]
            x2 = coord12[fn, 0]
            y2 = coord12[fn, 1]
            B1 = B1 + ((y1+y2)*(y1**2+y2**2)/4+(y1*(2*x1**2+(x1+x2)**2)+y2*(2*x2**2+(x1+x2)**2))/12)*L[i]*t[i]
            B2 = B2 + ((x1+x2)*(x1**2+x2**2)/4+(x1*(2*y1**2+(y1+y2)**2)+x2*(2*y2**2+(y1+y2)**2))/12)*L[i]*t[i]
        B1 = B1/I1 - 2*s12[1]
        B2 = B2/I2 - 2*s12[0]

        if np.abs(B1/np.sqrt(A)<1e-12):
            B1 = 0
        if np.abs(B2/np.sqrt(A)<1e-12):
            B2 = 0  
        # Compute rob
        if force == 'Pe':
            # tranfer the Pe eccentrecities coordinates to the centroid
            e12 = np.array([[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]]) @ exy
            rob = np.sqrt(ro**2 + B1*e12[1]+ B2*e12[0])
            a1 = s12[0] - e12[0]
            a2 = s12[1] - e12[1]
            if np.abs(a1/np.max(L)) < 1e-12:
                a1 = 0
            if np.abs(a2/np.max(L)) < 1e-12:
                a2 = 0
        else:
            rob = ro
        # Compute flexural buckling and torsional buckling
        if force == 'Pe' or force == 'Me12':
            Pe1 = np.pi**2*E*I1/KL1**2
            Pe2 = np.pi**2*E*I2/KL2**2
        elif force == 'Me1':
            Pe2 = np.pi**2*E*I2/KL2**2
        elif force == 'Me2':
            Pe1 = np.pi**2*E*I1/KL1**2
        Pe3 = (G*J+np.pi**2*E*Cw/KL3**2)/rob**2

        # Compute the flexural-torsional buckling and lateral buckling
        # with its corresponding displacements coefficients
        A1 = []
        A2 = []
        A3 = []
        if force == 'Pe' and a1 == 0 and a2 == 0:
            Pe = [[Pe1], [Pe2], [Pe3]]
            Pe = Pe_out(Pe)
            for i in range(3):
                if Pe[i] ==Pe2:
                    A1.append(1)
                    A2.append(0)
                    A3.append(0)
                if Pe[i] ==Pe1:
                    A1.append(0)
                    A2.append(1)
                    A3.append(0)
                if Pe[i] ==Pe3:
                    A1.append(0)
                    A2.append(0)
                    A3.append(3)
        elif force=='Pe' and a1!=0 and a2==0:
            Pcr1 = Pe2
            B = 1-(a1/rob)**2
            Pcr2 = ((Pe1+Pe3)-np.sqrt((Pe1+Pe3)**2-4*B*Pe1*Pe3))/(2*B)
            Pcr3 = ((Pe1+Pe3)+np.sqrt((Pe1+Pe3)**2-4*B*Pe1*Pe3))/(2*B)
            Pe = [[Pcr1], [Pcr2], [Pcr3]]
            Pe = Pe_out(Pe)
            for i in range(3):
                if Pe[i]==Pe1:
                    A1.append(0)
                    A2.append(1)
                    A3.append(0)
                else:
                    A2.append(0)
                    A3.append(0)
                    A1.append(Pe[i]*a2((KL2/KL3)**2/(Pe2_Pe[i])))
        elif force=='Pe' and a1!=0 and a2!=0:
            c1 = a1**2 + a2**2 - rob**2
            c2 = rob**2*(Pe1 + Pe2 + Pe3) - Pe1*a2**2-Pe2*a1**2
            c3 = -rob**2*(Pe1*Pe2+Pe1*Pe3+Pe2*Pe3)
            c4 = rob**2*Pe1*Pe2*Pe3
            Pe = np.sort(np.roots([c1, c2, c3, c4]))
            Pe = Pe_out(Pe)
            for i in range(3):
                A1.append(1)
                A3.append((Pe2-Pe[i])*(KL3/KL2)**2/(Pe[i]*a2))
                A2.append(-Pe[i]*a1*A3[i]*(KL1/KL3)**2/(Pe1-Pe[i]))
        elif force == 'Me1':
            Pcr1 = -Pe2/2*(B1 + np.sqrt(B1**2 + 4*rob**2*Pe3/Pe2))
            Pcr2 = -Pe2/2*(B1 - np.sqrt(B1**2 + 4*rob**2*Pe3/Pe2))
            Pe = [[Pcr1], [Pcr2]]
            Pe = Pe_out(Pe)
            for i in range(2):
                A1.append(0)
                A2.append(1)
                A3.append(-Pe2*(KL3/KL2)**2/Pe[i])
        elif force == 'Me2':
            Pcr1 = -Pe1/2*(B2 + np.sqrt(B2**2 + 4*rob**2*Pe3/Pe1))
            Pcr2 = -Pe1/2*(B2 - np.sqrt(B2**2 + 4*rob**2*Pe3/Pe1))
            Pe = np.array([[Pcr1], [Pcr2]])
            Pe = Pe_out(Pe)
            for i in range(2):
                A1.append(0)
                A2.append(1)
                A3.append(-Pe1*(KL3/KL1)**2/Pe[i])
        elif force == 'Me12':
            c = exy
            Pcr1 = -((B1*c+B2)+np.sqrt((B1*c+B2)**2+4*rob**2*Pe3*(c**2/Pe2+1/Pe1)))/(2*(c**2/Pe2+1/Pe1))
            Pcr2 = -((B1*c+B2)-np.sqrt((B1*c+B2)**2+4*rob**2*Pe3*(c**2/Pe2+1/Pe1)))/(2*(c**2/Pe2+1/Pe1))
            Pe = [[Pcr1], [Pcr2]]
            Pe = Pe_out(Pe)
            for i in range(2):
                A2.append(1)
                A3.append(Pe1*(KL3/KL1)**2/Pe[i])
                A1.append(-c*Pe[i]*A3[i]*(KL2/KL3)**2/Pe2)
        #Normalize the displacement coefficients
        for i in range(len(Pe)):
            An = np.linalg.norm([A1, A2, A3])
            A1[i] = (dist*A1[i]/An)
            A2[i] = (dist*A2[i]/An)
            A3[i] = (dist*A3[i]/An)
        A1 = np.array(A1).flatten()
        A2 = np.array(A2).flatten()
        A3 = np.array(A3).flatten()
        #Compute the deformed buckling shape
        xcoord = np.zeros((len(coord12), 2))
        dcoord = np.zeros((len(xcoord), 2, len(Pe)))
        for i in range(len(Pe)):
            xcoord[:, 0] = coord12[:, 0]-s12[0]
            xcoord[:, 1] = coord12[:, 1]-s12[1]
            xcoord = np.array([[np.cos(-A3[i]), np.sin(-A3[i])], [-np.sin(-A3[i]), np.cos(-A3[i])]]) @ (xcoord.T)
            xcoord = np.transpose(xcoord)
            xcoord[:, 0] = xcoord[:, 0]+s12[0]+A1[i]
            xcoord[:, 1] = xcoord[:, 1]+s12[1]+A2[i]
            #transfer the deformed buckling shape coordinates to the x-y coordinates
            xcoord = [[np.cos(-theta), np.sin(-theta)], [-np.sin(-theta), np.cos(-theta)]]@np.transpose(xcoord)
            xcoord = np.transpose(xcoord)
            xcoord[:, 0] = xcoord[:, 0]+xc
            xcoord[:, 1] = xcoord[:, 1]+yc
            dcoord[:,:,i] = xcoord

        return A,xc,yc,Ix,Iy,Ixy,theta,I1,I2,J,xs,ys,Cw,B1,B2,Pe,dcoord
def cutwp_draw(coord, ends,exy,xc,yc,theta,xs,ys,dcoord,origin,centroid,axisxy,axis12,shear,axial,deform,node,mode):
    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.patches import Polygon
    # Draw the cross section
    coord = np.array(coord)
    ends = np.array(ends)
    dcoord = np.array(dcoord)
    mode = int(mode)
    nele = len(ends)
    fig, ax1 = plt.subplots()
    for j in range(nele):
        sn = int(ends[j, 0]) - 1
        fn = int(ends[j, 1]) - 1
        u = coord[fn, 0] - coord[sn, 0]
        v = coord[fn, 1] - coord[sn, 1]
        phi = (np.angle([u+v*1j]))[0]
        xsn1 = coord[sn, 0] + ends[j, 2]*np.sin(phi)/2
        xfn1 = coord[fn, 0] + ends[j, 2]*np.sin(phi)/2
        ysn1 = coord[sn, 1] - ends[j, 2]*np.cos(phi)/2
        yfn1 = coord[fn, 1] - ends[j, 2]*np.cos(phi)/2
        xsn2 = coord[sn, 0] - ends[j, 2]*np.sin(phi)/2
        xfn2 = coord[fn, 0] - ends[j, 2]*np.sin(phi)/2
        ysn2 = coord[sn, 1] + ends[j, 2]*np.cos(phi)/2
        yfn2 = coord[fn, 1] + ends[j, 2]*np.cos(phi)/2      
        points = np.array([[xsn1, ysn1], [xsn2, ysn2], [xfn2, yfn2], [xfn1, yfn1]])
        plt.plot([coord[sn, 0], coord[fn, 0]], [coord[sn, 1], coord[fn, 1]], 'bo', markersize = 0.5 )
        polygon = Polygon(points, True, ec = 'b', fc = (1,1,0,1), lw=0.5)
        ax1.add_artist(polygon)
    k = np.array(ends[:,0:2]-1).T.flatten()
    k = k.astype(int)
    # for j in range(len(k)):
    #     k[j] = int(k[j])
    minx = np.min(coord[k, 0])
    maxx = np.max(coord[k, 0])
    miny = np.min(coord[k, 1]) 
    maxy = np.max(coord[k, 1])
    maxxy = np.max([maxx - minx, maxy - miny])/2
    x1 = xc - 1.1*maxxy
    x2 = xc + 1.1*maxxy
    y1 = yc - 1.1*maxxy
    y2 = yc + 1.1*maxxy
    if deform == 1:
        for j in range(nele):
            sn = int(ends[j, 0]) - 1
            fn = int(ends[j, 1]) - 1
            u = dcoord[fn, 0, mode] - dcoord[sn, 0, mode]
            v = dcoord[fn, 1, mode] - dcoord[sn, 1, mode]
            phi = (np.angle([u+v*1j]))[0]
            xsn1 = dcoord[sn, 0, mode] + ends[j, 2]*np.sin(phi)/2
            xfn1 = dcoord[fn, 0, mode] + ends[j, 2]*np.sin(phi)/2
            ysn1 = dcoord[sn, 1, mode] - ends[j, 2]*np.cos(phi)/2
            yfn1 = dcoord[fn, 1, mode] - ends[j, 2]*np.cos(phi)/2
            xsn2 = dcoord[sn, 0, mode] - ends[j, 2]*np.sin(phi)/2
            xfn2 = dcoord[fn, 0, mode] - ends[j, 2]*np.sin(phi)/2
            ysn2 = dcoord[sn, 1, mode] + ends[j, 2]*np.cos(phi)/2
            yfn2 = dcoord[fn, 1, mode] + ends[j, 2]*np.cos(phi)/2      
            points = np.array([[xsn1, ysn1], [xsn2, ysn2], [xfn2, yfn2], [xfn1, yfn1]])
            plt.plot([coord[sn, 0], coord[fn, 0]], [coord[sn, 1], coord[fn, 1]], 'bo', markersize = 0.5 )
            polygon = Polygon(points, True, ec = 'b', fc = 'r', lw=0.5)
            ax1.add_artist(polygon)
        minx = np.min(dcoord[k, 0, mode])  
        maxx = np.max(dcoord[k, 0, mode])  
        miny = np.min(dcoord[k, 1, mode]) 
        maxy = np.max(dcoord[k, 1, mode])
    if axisxy == 1:
        plt.plot([x1, x2], [yc, yc], 'g-')
        plt.text(x2, yc, '  X', color = 'g')
        plt.plot([xc, xc], [y1, y2], 'g-')
        plt.text(xc, y2, '  Y', color = 'g')
        minx = np.min([minx, x1, x2])
        maxx = np.max([maxx, x1, x2])
        miny = np.min([miny, y1, y2])
        maxy = np.max([maxy, y1, y2])
    
    if axis12 == 1:
        pxy = np.array([[x1-xc, x2-xc, 0, 0], [0, 0, y1-yc, y2-yc]])
        pxy = np.array([[np.cos(-theta), np.sin(-theta)], [-np.sin(-theta), np.cos(-theta)]])@pxy
        pxy[0, :] = pxy[0, :] + xc
        pxy[1, :] = pxy[1, :] + yc
        px1 = pxy[0, 0]
        py1 = pxy[1, 0]
        px2 = pxy[0, 1]
        py2 = pxy[1, 1]
        px3 = pxy[0, 2]
        py3 = pxy[1, 2]
        px4 = pxy[0, 3]
        py4 = pxy[1, 3]
        plt.plot([px1, px2], [py1, py2], 'r-.')
        plt.text(px2, py2, '  1', color = 'r')
        plt.plot([px3, px4], [py3, py4], 'r-.')
        plt.text(px4, py4, '  2', color = 'r')
        minx = np.min([minx, px1, px2, px3, px4])
        maxx = np.max([minx, px1, px2, px3, px4])
        miny = np.min([miny, py1, py2, py3, py4])
        maxy = np.max([maxy, py1, py2, py3, py4])
    
    if origin == 1:
        plt.plot(0, 0, '.w')
        plt.text(0, 0, 'O')
        minx = np.min([minx, 0])
        maxx = np.max([maxx, 0])
        miny = np.min([miny, 0])
        maxy = np.max([maxy, 0])
    
    if centroid ==1:
        plt.plot(xc, yc, '.w')
        plt.text(xc, yc, '  C',)
        minx = np.min([minx, xc])
        maxx = np.max([maxx, xc])
        miny = np.min([miny, yc])
        maxy = np.max([maxy, yc])

    if shear == 1:
        plt.plot(xs, ys, '.w')
        plt.text(xs, ys, '  S', color = 'r')
        minx = np.min([minx, xs])
        maxx = np.max([maxx, xs])
        miny = np.min([miny, ys])
        maxy = np.max([maxy, ys])

    if axial == 1:
        plt.plot(exy[0]+xc, exy[1]+yc, '.w')
        plt.text(exy[0]+xc, exy[1]+yc,'  Pe')
        minx = np.min([minx, exy[0]])
        maxx = np.max([maxx, exy[0]])
        miny = np.min([miny, exy[1]])
        maxy = np.max([maxy, exy[1]])
    
    if node == 1:
        for i in range(nele):
            sn = int(ends[i, 0]) - 1
            fn = int(ends[i, 1]) - 1
            xm = np.mean([coord[sn, 0], coord[fn, 0]])
            ym = np.mean([coord[sn, 1], coord[fn, 1]])
            plt.text(coord[sn, 0], coord[sn, 1], str(sn))
            plt.plot(coord[sn, 0], coord[sn, 1], '.w')
            plt.text(coord[fn, 0], coord[fn, 1], str(fn))
            plt.plot(coord[fn, 0], coord[fn, 1], '.w')
            plt.text(xm, ym, str(i), color = 'm')
    meanx = np.mean([maxx, minx])
    meany = np.mean([maxy, miny])
    maxxy = np.max([maxx-minx, maxy-miny])/2

    # Set color and axis of the figure
    plt.xlim(meanx - 1.4*maxxy, meanx + 1.4*maxxy)
    plt.ylim(meany - 1.4*maxxy, meany + 1.4*maxxy)
    plt.gca().set_aspect('equal', adjustable = 'box')
    plt.axis('off')
    plt.savefig('plot.png')
    # plt.show()
class Ui_MainWindow(object):
    def setupUi(self, MainWindow, input1):
        if(self.input1['tab']==1):
            self.force = 'Pe'
        Mes = ['Me1', 'Me2', 'Me12']
        if(self.input1['tab']==2):
            self.force = Mes[self.input1['subtab']-1]
        self.node_dat = input1['node_dat']
        self.elem_dat = input1['elem_dat']
        self.E = input1['E']
        self.v = input1['v']
        self.KL1 = input1['KL1']
        self.KL2 = input1['KL2']
        self.KL3 = input1['KL3']
        self.exy = input1['exy']
        self.coord = self.node_dat
        self.ends = self.elem_dat
        self.A,self.xc,self.yc,self.Ix,self.Iy,self.Ixy,self.theta,self.I1,self.I2,self.J,self.xs,self.ys,self.Cw,self.B1,self.B2,self.Pe,self.dcoord = cutwp_prop(self.coord,self.ends,self.KL1,self.KL2,self.KL3,self.force,self.exy,self.E,self.v,1)
        self.C = [self.xc, self.yc]
        self.SC = [self.xs, self.ys]
        self.tab = input1['tab']
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1107, 439)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.Node_Box =QtWidgets.QVBoxLayout(self.centralwidget)
        self.Elem_Box =QtWidgets.QVBoxLayout(self.centralwidget)
        self.Prop_Box =QtWidgets.QVBoxLayout(self.centralwidget)
        self.Node_Box.setGeometry(QtCore.QRect(0,0, 141, 181))
        self.Node_Data_Lab = QtWidgets.QLabel(self.centralwidget)
        self.Node_Data_Lab.setGeometry(QtCore.QRect(10, 10, 131, 21))
        self.Node_Data_Lab.setObjectName("Node_Data_Lab")
        self.Node_Data_Lab.setLayout(self.Node_Box)
        self.Element_Data_Lab = QtWidgets.QLabel(self.centralwidget)
        self.Element_Data_Lab.setGeometry(QtCore.QRect(170, 10, 91, 21))
        self.Element_Data_Lab.setObjectName("Element_Data_Lab")
        self.N_D_xy_Lab = QtWidgets.QLabel(self.centralwidget)
        self.N_D_xy_Lab.setGeometry(QtCore.QRect(10, 30, 131, 21))
        self.N_D_xy_Lab.setObjectName("N_D_xy_Lab")
        self.E_D_jkt_Lab = QtWidgets.QLabel(self.centralwidget)
        self.E_D_jkt_Lab.setGeometry(QtCore.QRect(170, 30, 101, 21))
        font = QtGui.QFont()
        font.setPointSize(7)
        self.E_D_jkt_Lab.setFont(font)
        self.E_D_jkt_Lab.setObjectName("E_D_jkt_Lab")
        self.Node_Data_inp = QtWidgets.QTextEdit(self.centralwidget)
        self.Node_Data_inp.setGeometry(QtCore.QRect(10, 50, 141, 131))
        self.Node_Data_inp.setObjectName("Node_Data_inp")
        self.Element_Data_inp = QtWidgets.QTextEdit(self.centralwidget)
        self.Element_Data_inp.setGeometry(QtCore.QRect(170, 50, 101, 131))
        self.Element_Data_inp.setObjectName("Element_Data_inp")
        self.E_lab = QtWidgets.QLabel(self.centralwidget)
        self.E_lab.setGeometry(QtCore.QRect(10, 190, 141, 21))
        self.E_lab.setObjectName("E_lab")
        self.v_lab = QtWidgets.QLabel(self.centralwidget)
        self.v_lab.setGeometry(QtCore.QRect(10, 210, 141, 21))
        self.v_lab.setObjectName("v_lab")
        self.E_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.E_inp.setGeometry(QtCore.QRect(170, 190, 101, 17))
        self.E_inp.setObjectName("E_inp")
        self.v_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.v_inp.setGeometry(QtCore.QRect(170, 210, 101, 17))
        self.v_inp.setObjectName("v_inp")
        self.KL_Label = QtWidgets.QLabel(self.centralwidget)
        self.KL_Label.setGeometry(QtCore.QRect(10, 230, 261, 21))
        self.KL_Label.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.KL_Label.setIndent(38)
        self.KL_Label.setObjectName("KL_Label")
        if(input1['tab']==1 or self.force == 'Me2'):
            self.KL1_lab = QtWidgets.QLabel(self.centralwidget)
            self.KL1_lab.setGeometry(QtCore.QRect(10, 250, 171, 21))
            self.KL1_lab.setLayoutDirection(QtCore.Qt.LeftToRight)
            self.KL1_lab.setIndent(-1)
            self.KL1_lab.setObjectName("KL1_lab")
            self.KL1_inp = QtWidgets.QLineEdit(self.centralwidget)
            self.KL1_inp.setGeometry(QtCore.QRect(170, 250, 101, 17))
            self.KL1_inp.setObjectName("KL1_inp")
        if(input1['tab']==1 or self.force == 'Me1'):
            self.KL2_lab = QtWidgets.QLabel(self.centralwidget)
            self.KL2_lab.setGeometry(QtCore.QRect(10, 270, 171, 21))
            self.KL2_lab.setLayoutDirection(QtCore.Qt.LeftToRight)
            self.KL2_lab.setIndent(-1)
            self.KL2_lab.setObjectName("KL2_lab")            
            self.KL2_inp = QtWidgets.QLineEdit(self.centralwidget)
            self.KL2_inp.setGeometry(QtCore.QRect(170, 270, 101, 17))
            self.KL2_inp.setObjectName("KL2_inp")
        self.KL3_lab = QtWidgets.QLabel(self.centralwidget)
        self.KL3_lab.setGeometry(QtCore.QRect(10, 290, 171, 21))
        self.KL3_lab.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.KL3_lab.setIndent(-1)
        self.KL3_lab.setObjectName("KL3_lab")
        self.Ecr_P_check = QtWidgets.QCheckBox(self.centralwidget)
        self.Ecr_P_check.setGeometry(QtCore.QRect(10, 310, 171, 18))
        self.Ecr_P_check.setObjectName("Ecr_P_check")
        self.Ecr_M_check = QtWidgets.QCheckBox(self.centralwidget)
        self.Ecr_M_check.setGeometry(QtCore.QRect(10, 330, 181, 18))
        self.Ecr_M_check.setObjectName("Ecr_M_check")
        if(self.input1['tab'] == 1):
            self.Ecr_P_check.setChecked(True)
        else:
            self.Ecr_P_check.setChecked(False)
        if(self.input1['tab'] == 2):
            self.Ecr_M_check.setChecked(True)
        else:
            self.Ecr_M_check.setChecked(False)
        if(self.Ecr_P_check.isChecked()):
            self.Eccentrecities_lab = QtWidgets.QLabel(self.centralwidget)
            self.Eccentrecities_lab.setGeometry(QtCore.QRect(10, 370, 131, 21))
            self.Eccentrecities_lab.setLayoutDirection(QtCore.Qt.LeftToRight)
            self.Eccentrecities_lab.setIndent(-1)
            self.Eccentrecities_lab.setObjectName("Eccentrecities_lab")
            self.exx_x_y_lab = QtWidgets.QLabel(self.centralwidget)
            self.exx_x_y_lab.setGeometry(QtCore.QRect(170, 350, 101, 21))
            self.exx_x_y_lab.setLayoutDirection(QtCore.Qt.LeftToRight)
            self.exx_x_y_lab.setIndent(-1)
            self.exx_x_y_lab.setObjectName("exx_x_y_lab")
            self.Eccentrecities_inp = QtWidgets.QLineEdit(self.centralwidget)
            self.Eccentrecities_inp.setGeometry(QtCore.QRect(170, 370, 101, 17))
            self.Eccentrecities_inp.setObjectName("Eccentrecities_inp")
        if(self.Ecr_M_check.isChecked()):
            self.Me1_check = QtWidgets.QCheckBox(self.centralwidget)
            self.Me1_check.setGeometry(QtCore.QRect(10, 350, 171, 21))
            self.Me1_check.setObjectName("Me1_check")
            if(self.force == 'Me1'):
                self.Me1_check.setChecked(True)
            self.Me2_check = QtWidgets.QCheckBox(self.centralwidget)
            self.Me2_check.setGeometry(QtCore.QRect(10, 370, 171, 21))
            self.Me2_check.setObjectName("Me2_check")
            if(self.force == 'Me2'):
                self.Me2_check.setChecked(True)
            self.Me12_check = QtWidgets.QCheckBox(self.centralwidget)
            self.Me12_check.setGeometry(QtCore.QRect(10, 390, 171, 21))
            self.Me12_check.setObjectName("Me12_check")
            if(self.force == 'Me12'):
                self.Me12_check.setChecked(True)
            self.Me12_inp = QtWidgets.QLineEdit(self.centralwidget)
            self.Me12_inp.setGeometry(QtCore.QRect(170, 390, 101, 17))
            self.Me12_inp.setObjectName("Me12_inp")
        self.KL3_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.KL3_inp.setGeometry(QtCore.QRect(170, 290, 101, 17))
        self.KL3_inp.setObjectName("KL3_inp")
        self.checkBox_origin = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_origin.setGeometry(QtCore.QRect(770, 10, 61, 18))
        self.checkBox_origin.setObjectName("checkBox_origin")
        if(input1['origin']==1):
            self.checkBox_origin.setChecked(True)
        self.checkBox_centroid = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_centroid.setGeometry(QtCore.QRect(770, 30, 61, 18))
        self.checkBox_centroid.setObjectName("checkBox_centroid")
        if(input1['centroid']==1):
            self.checkBox_centroid.setChecked(True)
        self.checkBox_SC = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_SC.setGeometry(QtCore.QRect(840, 10, 81, 18))
        self.checkBox_SC.setObjectName("checkBox_SC")
        if(input1['SC']==1):
            self.checkBox_SC.setChecked(True)
        self.checkBox_AxialF = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_AxialF.setGeometry(QtCore.QRect(840, 30, 81, 18))
        self.checkBox_AxialF.setObjectName("checkBox_AxialF")
        if(input1['AF']==1):
            self.checkBox_AxialF.setChecked(True)
        self.checkBox_ax_xy = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_ax_xy.setGeometry(QtCore.QRect(770, 50, 71, 18))
        self.checkBox_ax_xy.setObjectName("checkBox_ax_xy")
        if(input1['axxy']==1):
            self.checkBox_ax_xy.setChecked(True)
        self.checkBox_DS = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_DS.setGeometry(QtCore.QRect(840, 50, 111, 18))
        self.checkBox_DS.setObjectName("checkBox_DS")
        if(input1['DS']==1):
            self.checkBox_DS.setChecked(True)
        self.checkBox_NandS = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_NandS.setGeometry(QtCore.QRect(840, 70, 111, 18))
        self.checkBox_NandS.setObjectName("checkBox_NandS")
        if(input1['N&S']==1):
            self.checkBox_NandS.setChecked(True)
        self.checkBox_ax_12 = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBox_ax_12.setGeometry(QtCore.QRect(770, 70, 71, 18))
        self.checkBox_ax_12.setObjectName("checkBox_ax_12")
        if(input1['ax12']==1):
            self.checkBox_ax_12.setChecked(True)
        self.Displ_Fact_lab = QtWidgets.QLabel(self.centralwidget)
        self.Displ_Fact_lab.setGeometry(QtCore.QRect(770, 100, 111, 21))
        self.Displ_Fact_lab.setObjectName("Displ_Fact_lab")
        self.Area_lab = QtWidgets.QLabel(self.centralwidget)
        self.Area_lab.setGeometry(QtCore.QRect(770, 130, 111, 21))
        self.Area_lab.setObjectName("Area_lab")
        self.Ix_lab = QtWidgets.QLabel(self.centralwidget)
        self.Ix_lab.setGeometry(QtCore.QRect(770, 150, 111, 21))
        self.Ix_lab.setObjectName("Ix_lab")
        self.Iy_lab = QtWidgets.QLabel(self.centralwidget)
        self.Iy_lab.setGeometry(QtCore.QRect(770, 170, 111, 21))
        self.Iy_lab.setObjectName("Iy_lab")
        self.Ixy_lab = QtWidgets.QLabel(self.centralwidget)
        self.Ixy_lab.setGeometry(QtCore.QRect(770, 190, 121, 21))
        self.Ixy_lab.setObjectName("Ixy_lab")
        self.J_lab = QtWidgets.QLabel(self.centralwidget)
        self.J_lab.setGeometry(QtCore.QRect(770, 270, 171, 21))
        self.J_lab.setObjectName("J_lab")
        self.I1_lab = QtWidgets.QLabel(self.centralwidget)
        self.I1_lab.setGeometry(QtCore.QRect(770, 210, 111, 21))
        self.I1_lab.setObjectName("I1_lab")
        self.Theta_lab = QtWidgets.QLabel(self.centralwidget)
        self.Theta_lab.setGeometry(QtCore.QRect(770, 250, 171, 21))
        self.Theta_lab.setObjectName("Theta_lab")
        self.I2_lab = QtWidgets.QLabel(self.centralwidget)
        self.I2_lab.setGeometry(QtCore.QRect(770, 230, 111, 21))
        self.I2_lab.setObjectName("I2_lab")
        self.B1_lab = QtWidgets.QLabel(self.centralwidget)
        self.B1_lab.setGeometry(QtCore.QRect(770, 350, 111, 21))
        self.B1_lab.setObjectName("B1_lab")
        self.Cent_lab = QtWidgets.QLabel(self.centralwidget)
        self.Cent_lab.setGeometry(QtCore.QRect(770, 290, 161, 21))
        self.Cent_lab.setObjectName("Cent_lab")
        self.W_lab = QtWidgets.QLabel(self.centralwidget)
        self.W_lab.setGeometry(QtCore.QRect(770, 330, 111, 21))
        self.W_lab.setObjectName("W_lab")
        self.SC_lab = QtWidgets.QLabel(self.centralwidget)
        self.SC_lab.setGeometry(QtCore.QRect(770, 310, 171, 21))
        self.SC_lab.setObjectName("SC_lab")
        self.B2_lab = QtWidgets.QLabel(self.centralwidget)
        self.B2_lab.setGeometry(QtCore.QRect(770, 370, 111, 21))
        self.B2_lab.setObjectName("B2_lab")
        self.A_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.A_inp.setGeometry(QtCore.QRect(970, 130, 114, 17))
        self.A_inp.setObjectName("A_inp")
        self.Ix_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.Ix_inp.setGeometry(QtCore.QRect(970, 150, 114, 17))
        self.Ix_inp.setObjectName("Ix_inp")
        self.Iy_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.Iy_inp.setGeometry(QtCore.QRect(970, 170, 114, 17))
        self.Iy_inp.setObjectName("Iy_inp")
        self.Ixy_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.Ixy_inp.setGeometry(QtCore.QRect(970, 190, 114, 17))
        self.Ixy_inp.setObjectName("Ixy_inp")
        self.Theta_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.Theta_inp.setGeometry(QtCore.QRect(970, 250, 114, 17))
        self.Theta_inp.setObjectName("Theta_inp")
        self.I1_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.I1_inp.setGeometry(QtCore.QRect(970, 210, 114, 17))
        self.I1_inp.setObjectName("I1_inp")
        self.J_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.J_inp.setGeometry(QtCore.QRect(970, 270, 114, 17))
        self.J_inp.setObjectName("J_inp")
        self.I2_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.I2_inp.setGeometry(QtCore.QRect(970, 230, 114, 17))
        self.I2_inp.setObjectName("I2_inp")
        self.SC_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.SC_inp.setGeometry(QtCore.QRect(970, 310, 114, 17))
        self.SC_inp.setObjectName("SC_inp")
        self.W_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.W_inp.setGeometry(QtCore.QRect(970, 330, 114, 17))
        self.W_inp.setObjectName("W_inp")
        self.B1_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.B1_inp.setGeometry(QtCore.QRect(970, 350, 114, 17))
        self.B1_inp.setObjectName("B1_inp")
        self.Cent_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.Cent_inp.setGeometry(QtCore.QRect(970, 290, 114, 17))
        self.Cent_inp.setObjectName("Cent_inp")
        self.B2_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.B2_inp.setGeometry(QtCore.QRect(970, 370, 114, 17))
        self.B2_inp.setObjectName("B2_inp")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.setGeometry(QtCore.QRect(980, 10, 101, 31))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(980, 50, 101, 31))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_3 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_3.setGeometry(QtCore.QRect(980, 90, 101, 31))
        self.pushButton_3.setObjectName("pushButton_3")
        self.Displ_Fact_inp = QtWidgets.QLineEdit(self.centralwidget)
        self.Displ_Fact_inp.setGeometry(QtCore.QRect(910, 100, 51, 17))
        self.Displ_Fact_inp.setObjectName("Displ_Fact_inp")
        self.Plot = QtWidgets.QLabel(self.centralwidget)
        self.Plot.setGeometry(QtCore.QRect(280, 20, 471, 301))
        self.Plot.setText("")
        self.Plot.setPixmap(QtGui.QPixmap("plot.png"))
        self.Plot.setScaledContents(True)
        self.Plot.setObjectName("Plot")
        self.buckling_mode_lab = QtWidgets.QLabel(self.centralwidget)
        self.buckling_mode_lab.setGeometry(QtCore.QRect(350, 340, 81, 16))
        self.buckling_mode_lab.setObjectName("buckling_mode_lab")
        self.buck_mode_lab1 = QtWidgets.QLabel(self.centralwidget)
        self.buck_mode_lab1.setGeometry(QtCore.QRect(450, 340, 81, 16))
        self.buck_mode_lab1.setObjectName("buck_mode_lab1")
        self.BucklingModeSlider = QtWidgets.QScrollBar(self.centralwidget)
        self.BucklingModeSlider.setGeometry(QtCore.QRect(340, 370, 160, 16))
        if(self.tab == 1):
            self.BucklingModeSlider.setMinimum(1)
            self.BucklingModeSlider.setMaximum(3)
            self.BucklingModeSlider.setPageStep(1)
        elif(self.tab == 2):
            self.BucklingModeSlider.setMinimum(1)
            self.BucklingModeSlider.setMaximum(2)
            self.BucklingModeSlider.setPageStep(1)
        self.BucklingModeSlider.setOrientation(QtCore.Qt.Horizontal)
        self.BucklingModeSlider.setObjectName("BucklingModeSlider")
        self.AxialForcelab = QtWidgets.QLabel(self.centralwidget)
        self.AxialForcelab.setGeometry(QtCore.QRect(520, 370, 47, 14))
        self.AxialForcelab.setObjectName("AxialForcelab")
        self.AxialForcelab2 = QtWidgets.QLabel(self.centralwidget)
        self.AxialForcelab2.setGeometry(QtCore.QRect(570, 370, 47, 14))
        self.AxialForcelab2.setObjectName("AxialForcelab2")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1107, 22))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.menuFile.addSeparator()
        self.menubar.addAction(self.menuFile.menuAction())
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

        self.pushButton_3.clicked.connect(self.Apply)

        self.BucklingModeSlider.valueChanged.connect(self.Mode)

        self.Ecr_P_check.stateChanged.connect(lambda: self.redraw(MainWindow))
        self.Ecr_M_check.stateChanged.connect(lambda: self.redrawM(MainWindow))
        if(self.input1['tab'] == 2):
            self.Me1_check.stateChanged.connect(lambda: self.redrawM1(MainWindow))
            self.Me2_check.stateChanged.connect(lambda: self.redrawM1(MainWindow))
            self.Me12_check.stateChanged.connect(lambda: self.redrawM1(MainWindow))

    def redraw(self, MainWindow):
        if(self.Ecr_P_check.isChecked() == True):
            self.input1['tab'] = 1
            self.readinput()
            self.setupUi(MainWindow, self.input1)
        # elif(self.Ecr_P_check.isChecked() == False):
        #     if(self.Ecr_M_check.isChecked() == False):
        #         self.Ecr_P_check.setChecked(True)
        #         self.input1['tab'] == 1
        #         self.readinput()
        #         self.setupUi(MainWindow, self.input1)
    def redrawM(self, MainWindow):
        if(self.Ecr_M_check.isChecked() == True):
            self.input1['tab'] = 2
            self.input1['subtab'] = 1
            self.readinput()
            self.setupUi(MainWindow, self.input1)
    def redrawM1(self, MainWindow):
        if(self.Me1_check.isChecked() == True):
            self.input1['subtab'] = 1
            self.readinput()
            self.setupUi(MainWindow, self.input1)
        elif(self.Me1_check.isChecked() == True):
            self.input1['subtab'] = 2
            self.readinput()
            self.setupUi(MainWindow, self.input1)
        elif(self.Me12_check.isChecked() == True):
            self.input1['subtab'] = 3
            self.readinput()
            self.setupUi(MainWindow, self.input1)
        # elif(self.Ecr_M_check.isChecked() == False):
        #     if(self.Ecr_P_check.isChecked() == False):
        #         self.Ecr_M_check.setChecked(True)
        #         self.input1['tab'] = 2
        #         self.input1['subtab'] = 1
        #         self.readinput()
        #         self.setupUi(MainWindow, self.input1)
        
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "CUTWP"))
        self.Node_Data_Lab.setText(_translate("MainWindow", "Node Data:"))
        self.Element_Data_Lab.setText(_translate("MainWindow", "Element Data:"))
        self.N_D_xy_Lab.setText(_translate("MainWindow", "xcoord, ycoord"))
        self.E_D_jkt_Lab.setText(_translate("MainWindow", "node-j,node-k,thickness"))
        self.Node_Data_inp.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8pt; font-weight:400; font-style:normal;\">\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[0,0]} {self.node_dat[0,1]}</p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[1,0]} {self.node_dat[1,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[2,0]} {self.node_dat[2,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[3,0]} {self.node_dat[3,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[4,0]} {self.node_dat[4,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[5,0]} {self.node_dat[5,1]}</p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[6,0]} {self.node_dat[6,1]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[7,0]} {self.node_dat[7,1]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[8,0]} {self.node_dat[8,1]}</p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[9,0]} {self.node_dat[9,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[10,0]} {self.node_dat[10,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[11,0]} {self.node_dat[11,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[12,0]} {self.node_dat[12,1]}  </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.node_dat[13,0]} {self.node_dat[13,1]}</p></body></html>"))
        self.Element_Data_inp.setHtml(_translate("MainWindow", "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
"<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
"p, li { white-space: pre-wrap; }\n"
"</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8pt; font-weight:400; font-style:normal;\">\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[0,0]} {self.elem_dat[0,1]}  {self.elem_dat[0,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[1,0]} {self.elem_dat[1,1]}  {self.elem_dat[1,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[2,0]} {self.elem_dat[2,1]}  {self.elem_dat[2,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[3,0]} {self.elem_dat[3,1]}  {self.elem_dat[3,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[4,0]} {self.elem_dat[4,1]}  {self.elem_dat[4,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[5,0]} {self.elem_dat[5,1]}  {self.elem_dat[5,2]}</p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[6,0]} {self.elem_dat[6,1]}  {self.elem_dat[6,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[7,0]} {self.elem_dat[7,1]}  {self.elem_dat[7,2]}</p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[8,0]} {self.elem_dat[8,1]}  {self.elem_dat[8,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[9,0]} {self.elem_dat[9,1]}  {self.elem_dat[9,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[10,0]} {self.elem_dat[10,1]}  {self.elem_dat[10,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[11,0]} {self.elem_dat[11,1]}  {self.elem_dat[11,2]} </p>\n"
f"<p style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">{self.elem_dat[12,0]} {self.elem_dat[12,1]}  {self.elem_dat[12,2]} </p></body></html>"))
        self.E_lab.setText(_translate("MainWindow", "Elastic Modulus, E:"))
        self.v_lab.setText(_translate("MainWindow", "Poisson\'s ratio, v:"))
        self.E_inp.setText(_translate("MainWindow", f"{self.E}"))
        self.v_inp.setText(_translate("MainWindow", f"{self.v}"))
        self.KL_Label.setText(_translate("MainWindow", "Effective Unbraced Length:"))
        self.KL3_lab.setText(_translate("MainWindow", "Bending about the 3-axis, KL3:"))
        self.Ecr_P_check.setText(_translate("MainWindow", "Elastic Critical Axial Force, Pe"))
        self.Ecr_M_check.setText(_translate("MainWindow", "Elastic Critical Moment, Me"))
        if(self.tab == 1 or self.force == 'Me2'):
            self.KL1_lab.setText(_translate("MainWindow", "Bending about the 1-axis, KL1:"))
            self.KL1_inp.setText(_translate("MainWindow", f"{self.KL1}"))
        if(self.tab == 1 or self.force == 'Me1'):
            self.KL2_lab.setText(_translate("MainWindow", "Bending about the 2-axis, KL2:"))
            self.KL2_inp.setText(_translate("MainWindow", f"{self.KL2}"))
        self.KL3_inp.setText(_translate("MainWindow", f"{self.KL3}"))
        self.checkBox_origin.setText(_translate("MainWindow", "Origin"))
        self.checkBox_centroid.setText(_translate("MainWindow", "Centroid"))
        self.checkBox_SC.setText(_translate("MainWindow", "Shear center"))
        self.checkBox_AxialF.setText(_translate("MainWindow", "Axial Force"))
        self.checkBox_ax_xy.setText(_translate("MainWindow", "Axis(x, y)"))
        self.checkBox_DS.setText(_translate("MainWindow", "Deformed Shape"))
        self.checkBox_NandS.setText(_translate("MainWindow", "Node and segment"))
        self.checkBox_ax_12.setText(_translate("MainWindow", "Axis(1, 2)"))
        self.Displ_Fact_lab.setText(_translate("MainWindow", "Displacement factor:"))
        self.Area_lab.setText(_translate("MainWindow", "Area:"))
        self.Ix_lab.setText(_translate("MainWindow", "Moment of inertia, Ix:"))
        self.Iy_lab.setText(_translate("MainWindow", "Moment of inertia, Iy:"))
        self.Ixy_lab.setText(_translate("MainWindow", "Product of inertia, Ixy:"))
        self.J_lab.setText(_translate("MainWindow", "Torsion Constant-Open Section, J"))
        self.I1_lab.setText(_translate("MainWindow", "Moment of inertia, I1:"))
        self.Theta_lab.setText(_translate("MainWindow", "Angle for Principle direction, theta "))
        self.I2_lab.setText(_translate("MainWindow", "Moment of inertia, I2:"))
        self.B1_lab.setText(_translate("MainWindow", "B1:"))
        self.Cent_lab.setText(_translate("MainWindow", "Centroid Coordinates, (x, y):"))
        self.W_lab.setText(_translate("MainWindow", "Warping Constant, W:"))
        self.SC_lab.setText(_translate("MainWindow", "Shear Center Coordinates, (x, y):"))
        self.B2_lab.setText(_translate("MainWindow", "B2:"))
        self.A_inp.setText(_translate("MainWindow", f"{self.A}"))
        self.Ix_inp.setText(_translate("MainWindow", f"{self.Ix}"))
        self.Iy_inp.setText(_translate("MainWindow", f"{self.Iy}"))
        self.Ixy_inp.setText(_translate("MainWindow", f"{self.Ixy}"))
        self.Theta_inp.setText(_translate("MainWindow", f"{self.theta}"))
        self.I1_inp.setText(_translate("MainWindow", f"{self.I1}"))
        self.J_inp.setText(_translate("MainWindow", f"{self.J}"))
        self.I2_inp.setText(_translate("MainWindow", f"{self.I2}"))
        self.SC_inp.setText(_translate("MainWindow", f"{self.SC[0]}, {self.SC[1]}"))
        self.W_inp.setText(_translate("MainWindow", f"{self.Cw}"))
        self.B1_inp.setText(_translate("MainWindow", f"{self.B1}"))
        self.Cent_inp.setText(_translate("MainWindow", f"{self.C[0]}, {self.C[1]}"))
        self.B2_inp.setText(_translate("MainWindow", f"{self.B2}"))
        self.pushButton.setText(_translate("MainWindow", "Open.."))
        self.pushButton.setShortcut(_translate("MainWindow", "Ctrl+O"))
        self.pushButton_2.setText(_translate("MainWindow", "Save As.."))
        self.pushButton_2.setShortcut(_translate("MainWindow", "Ctrl+S"))
        self.pushButton_3.setText(_translate("MainWindow", "Apply.."))
        self.pushButton_3.setShortcut(_translate("MainWindow", "Return"))
        self.Displ_Fact_inp.setText(_translate("MainWindow", "1"))
        self.buckling_mode_lab.setText(_translate("MainWindow", "Buckling mode:"))
        if(self.tab == 1):
            self.buck_mode_lab1.setText(_translate("MainWindow", "1/3"))
            self.AxialForcelab.setText(_translate("MainWindow", "Pe"))
            self.AxialForcelab2.setText(_translate("MainWindow", "15.509"))
        elif(self.tab == 2):
            self.buck_mode_lab1.setText(_translate("MainWindow", "1/2"))
            self.AxialForcelab.setText(_translate("MainWindow", "Me"))
            self.AxialForcelab2.setText(_translate("MainWindow", f"{self.Pe[0]}"))           
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        if(self.Ecr_P_check.isChecked()):
            self.Eccentrecities_lab.setText(_translate("MainWindow", "Eccentrecities about the:"))
            self.exx_x_y_lab.setText(_translate("MainWindow", "xaxis, yaxis"))
            self.Eccentrecities_inp.setText(_translate("MainWindow", "0 0 "))
        if(self.Ecr_M_check.isChecked()):
            self.Me1_check.setText(_translate("MainWindow", "Bending about the 1-axis,Me1:"))
            self.Me2_check.setText(_translate("MainWindow", "Bending about the 2-axis,Me2:"))
            self.Me12_check.setText(_translate("MainWindow", "Biaxial Bending,Me1/Me2:"))
            self.Me12_inp.setText(_translate("MainWindow", "0"))
        
    # def Ecr_M_check_clicked(self):


    def getNumbers(self, str): 
        array = re.findall(r'[0-9,.,-]+', str) 
        return array
    def readinput(self):
        nodes_line = [float(x) for x in self.getNumbers(self.Node_Data_inp.toPlainText())]
        self.coord = np.zeros((int(len(nodes_line)/2), 2))
        for i in range(int(len(nodes_line)/2)):
            for j in range(2):
                self.coord[i, j] = nodes_line[2*i+j]
        self.input1['node_dat'] = self.coord
        element_line = [float(x) for x in self.getNumbers(self.Element_Data_inp.toPlainText())]
        self.ends = np.zeros((int(len(element_line)/3), 3))
        for i in range(int(len(element_line)/3)):
            for j in range(3):
                if((j+1)%3==1 or (j+1)%3==2):
                    self.ends[i,j] = int(element_line[3*i+j])
                else:
                    self.ends[i, j] = element_line[3*i+j]
        self.input1['elem_dat'] = self.ends
        self.E = float(self.E_inp.text())
        self.input1['E'] = self.E
        self.v = float(self.v_inp.text())
        self.input1['v'] = self.v
        if(self.tab == 1 or self.force == 'Me2'):
            self.KL1 = float(self.KL1_inp.text())
            self.input1['KL1'] = self.KL1
        else:
            self.KL1 = 60
            self.input1['KL1'] = self.KL1
        if(self.tab ==1 or self.force == 'Me1'):
            self.KL2 = float(self.KL2_inp.text())
            self.input1['KL2'] = self.KL2
        else:
            self.KL2 = 60
            self.input1['KL2'] = self.KL2
        self.KL3 = float(self.KL3_inp.text())
        self.input1['KL3'] = self.KL3
        if(self.Ecr_P_check== True):
            self.exy = [float(x) for x in self.getNumbers(self.Eccentrecities_inp.text())]
            self.input1['exy'] = self.exy
        else:
            self.exy = np.array([0, 0])
            self.input1['exy'] = self.exy
        if(self.Ecr_P_check.isChecked() == True):
            self.force = 'Pe'
        elif(self.Ecr_M_check.isChecked() == True):
            if(self.Me1_check.isChecked()== True):
                self.force = 'Me1'
                self.input1['subtab'] = 1
            if(self.Me2_check.isChecked()== True):
                self.force = 'Me2'  
                self.input1['subtab'] = 2
            if(self.Me12_check.isChecked()== True):
                self.force = 'Me12'  
                self.input1['subtab'] = 3
        if(self.checkBox_origin.isChecked()==True):
            self.origin = 1
            self.input1['origin'] = 1
        else:
            self.origin = 0
            self.input1['origin'] = 0
        if(self.checkBox_ax_12.isChecked()==True):
            self.axis12 = 1
            self.input1['ax12'] = 1
        else:
            self.axis12 = 0
            self.input1['ax12'] = 0
        if(self.checkBox_ax_xy.isChecked() == True):
            self.axisxy = 1
            self.input1['axxy'] = 1
        else:
            self.axisxy = 0
            self.input1['axxy'] = 0
        if(self.checkBox_centroid.isChecked() == True):
            self.centroid = 1
            self.input1['centroid'] = 1
        else:
            self.centroid = 0
            self.input1['centroid'] = 0
        if(self.checkBox_SC.isChecked() == True):
            self.shear = 1
            self.input1['SC'] = 1
        else:
            self.shear = 0 
            self.input1['SC'] = 0
        if(self.checkBox_DS.isChecked() == True):
            self.deform = 1
            self.input1['DS'] = 1
        else:
            self.deform = 0
            self.input1['DS'] = 0
        if(self.checkBox_NandS.isChecked() == True):
            self.node = 1
            self.input1['N&S'] = 1
        else:
            self.node = 0
            self.input1['N&S'] = 0
        if(self.checkBox_AxialF.isChecked() == True):
            self.axial = 1
            self.input1['AF'] = 1
        else:
            self.axial = 0
            self.input1['AF'] = 0
        self.mode = self.BucklingModeSlider.value()-1
    def Apply(self):
        self.readinput()    
        self.dist = 1
        self.A,self.xc,self.yc,self.Ix,self.Iy,self.Ixy,self.theta,self.I1,self.I2,self.J,self.xs,self.ys,self.Cw,self.B1,self.B2,self.Pe,self.dcoord = cutwp_prop(self.coord,self.ends,self.KL1,self.KL2,self.KL3,self.force,self.exy,self.E,self.v,self.dist)
        cutwp_draw(self.coord, self.ends,self.exy,self.xc,self.yc,self.theta,self.xs,self.ys,self.dcoord,self.origin,self.centroid,self.axisxy,self.axis12,self.shear,self.axial,self.deform,self.node,self.mode)
        self.Plot.setPixmap(QtGui.QPixmap("plot.png"))
    def Mode(self):
        self.readinput()
        self.mode = self.BucklingModeSlider.value()-1
        cutwp_draw(self.coord, self.ends,self.exy,self.xc,self.yc,self.theta,self.xs,self.ys,self.dcoord,self.origin,self.centroid,self.axisxy,self.axis12,self.shear,self.axial,self.deform,self.node,self.mode)
        self.Plot.setPixmap(QtGui.QPixmap("plot.png"))
if __name__ == "__main__":
    import sys
    input1= {
        'node_dat' : np.array([[1.565, -0.795],
                    [1.565, -1.5], 
                    [1.094, -1.5],
                    [0.563, -1.5],
                    [0, -1.5],
                    [0, -0.952],
                    [0, -0.44],
                    [0, 0.44],
                    [0, 0.952],
                    [0, 1.5],
                    [0.563, 1.5],
                    [1.094, 1.5],
                    [1.565, 1.5],
                    [1.565, 0.795]]), 
        'elem_dat' : np.array([[1, 2, 0.091], 
                    [2, 3, 0.091],
                    [3, 4, 0.073], 
                    [4, 5, 0.091],
                    [5, 6, 0.091], 
                    [6, 7, 0.0455],
                    [7, 8, 0.091 ],
                    [8, 9, 0.0455],
                    [9, 10,0.091], 
                    [10, 11, 0.091],
                    [11, 12, 0.073],
                    [12, 13, 0.091],
                    [13, 14, 0.091]]),
        'E' : 29500,
        'v' : 0.3,
        'KL1' : 60,
        'KL2' : 60,
        'KL3': 60,
        'exy' : [0, 0],
        'DF' : 1,
        'A' : 0.620432,
        'Ix' : 0.953286,
        'Iy' : 0.265125,
        'Ixy' : 0,
        'I1' : 0.953286,
        'I2' : 0.265125,
        'theta' : 0,
        'J' : 0.00153986,
        'C' : [0.65736, 0],
        'SC' : [-0.927725, 0],
        'Cw' : 0.763688,
        'B1' : 0,
        'B2' : 3.7984,
        'tab' : 1,
        'subtab' : 2,
        'origin': 0,
        'centroid' : 0,
        'SC': 1,
        'AF' : 0,
        'axxy' : 0,
        'ax12' : 1,
        'DS' : 1,
        'N&S': 0
    }

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.input1 = input1
    ui.setupUi(MainWindow, input1)
    MainWindow.show()
    sys.exit(app.exec_())
